{
  "language": "Solidity",
  "sources": {
    "contracts/ForGreen.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"./precompiles/stateful/Staking.sol\";\nimport \"./precompiles/stateful/Distribution.sol\";\n\ncontract ForGreen{\n\n\n    struct UnbondingRequest {\n        int64 completionTime;\n        uint256 amount;\n    }\n    /// @dev the required authorizations for Staking and Distribution\n    string[] private stakingMethods = [MSG_DELEGATE, MSG_UNDELEGATE, MSG_REDELEGATE];\n    string[] private distributionMethods = [MSG_WITHDRAW_DELEGATOR_REWARD];\n    /// @dev map to keep track of user deposits to the contract.\n    mapping(uint256 => uint256) public donated;                                // _ideas_ids       => (Ideas) donated amount\n    uint256 private _total_delegations;\n    string private _validatorAddr  = \"evmosvaloper158wwas4v6fgcu2x3plg70s6u0fm0lle237kltr\";\n    /// @dev map that keeps track of all currently unbonding delegations\n    mapping(uint256 => UnbondingRequest) public unbondingDelegations;           // _ideas_ids       => (Ideas) UnbondingRequest\n  \n\n\n\tuint256 private _tokenIds;\n\tuint256 private _bidIds;\n\tuint256 private _eventIds;\n    uint256 public _GrantEventIds;\n\tuint256 public _GrantProjectIds;\n\tuint256 public _GrantVoteIds;\n\tuint256 private _EventTokenIds;\n\tuint256 private _TokenBidIds;\n\tuint256 public _EventTokenSearchIds;\n\tmapping(uint256 => string[2]) private AllEventTokens;\n\tmapping(uint256 => string[3]) private AllGrantVotes;\n    mapping(uint256 => uint256[2]) private AllGrantProject;\n\tmapping(uint256 => string[2]) private AllTokensBids;\n\tmapping(uint256 => string[2]) public _SearchedStore;\n\tmapping(uint256 => string) private _bidURIs;\n\tmapping(uint256 => string) private _tokenURIs;\n\tmapping(uint256 => string[2]) private _eventURIs;\n\tmapping(uint256 => string) public _GrantEventURIs;\n    mapping(uint256 => string) public  _JudgerURIs;\n\tmapping(uint256 => string) private _eventRaised;\n\tmapping(string => string) private _eventTokens;\n\n\nfunction claimToken(\n\t\taddress _claimer,\n\t\tstring memory _tokenURI,\n\t\tuint256 _eventid\n\t) public returns (uint256) {\n\t\t_setTokenURI(_tokenIds, _tokenURI);\n\t\t_setTokenEvent(_EventTokenIds, _eventid, _tokenURI);\n\t\t_tokenIds++;\n\t\t_EventTokenIds++;\n\t\treturn _tokenIds;\n\t}\n\n\nfunction _setTokenEvent(\n\t\tuint256 EventTokenId,\n\t\tuint256 EventId,\n\t\tstring memory _tokenURI\n\t) public virtual {\n\t\tAllEventTokens[EventTokenId] = [\n\t\t\tStrings.toString(EventId),\n\t\t\tstring(_tokenURI)\n\t\t];\n\t}\nfunction createEvent(string memory _eventWallet,string memory _eventURI)\n\t\tpublic\n\t\treturns (uint256)\n\t{\n\t\t_setEventURI(_eventIds,_eventWallet, _eventURI);\n\t\t_setEventRaised(_eventIds, \"0\");\n\t\t_eventIds++;\n\n\t\treturn _eventIds;\n\t}\n\t\n\nfunction setGrantProject(\t\n\t\tuint256 GrantProjectId,\n\t\tuint256 ProjectId,\n\t\tuint256 GranttId\n\t) public virtual {\n\t\tAllGrantProject[GrantProjectId] = [GranttId,ProjectId];\n\n\t}\n\n\nfunction CreateGrantProject(\n\t\tuint256 ProjectId,\n\t\tuint256 GranttId\n\t) public returns (uint256) {\n\t\tsetGrantProject(_GrantProjectIds,ProjectId,GranttId);\n\t\t_GrantProjectIds++;\n\t\t\n\t\treturn _GrantProjectIds;\n\t}\n\n\n\n\nfunction createGrantEvent(string memory _eventURI)\n\t\tpublic\n\t\treturns (uint256)\n\t{\n\t\t_setGrantEventURI(_GrantEventIds, _eventURI);\n\t\t_GrantEventIds++;\n\n\t\treturn _GrantEventIds;\n\t}\n\n\nfunction getCheckSubmittedProjectGrant(uint256 Grantid, uint256 ProjectId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (bool)\n\t{\t\t\n\t\t\n\t\tfor (uint256 i = 0; i < _GrantProjectIds; i++) {\n\t\t\tif (\n\t\t\t\tAllGrantProject[i][0] == Grantid && \n\t\t\t\tAllGrantProject[i][1] == ProjectId \t\t\t\t\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\nfunction getSearchedProjectByGrantID(uint256 Grantid)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (uint256[] memory)\n\t{\n\t\t\n\t\tuint256 _TemporarySearch = 0;\n\t\tuint256 _SearchIds = 0;\n\t\t\n\t\t\n\t\tfor (uint256 i = 0; i < _GrantProjectIds; i++) {\n\t\t\tif (\n\t\t\t\tAllGrantProject[i][0] == Grantid\n\t\t\t) {\n\t\t\t\t_TemporarySearch++;\n\t\t\t}\n\t\t}\n\t\tuint256[] memory _SearchedProject = new uint256[](_TemporarySearch);\n\n\t\tfor (uint256 i = 0; i < _GrantProjectIds; i++) {\n\t\t\tif (\n\t\t\t\tAllGrantProject[i][0] == Grantid\n\t\t\t) {\n\t\t\t\t_SearchedProject[_SearchIds] = AllGrantProject[i][1];\n\t\t\t\t_SearchIds++;\n\t\t\t}\n\t\t}\n\n\n\t\treturn _SearchedProject;\n\t}\n\nfunction setGrantVote(\t\n\t\tuint256 GrantVoteId,\n\t\tstring memory Wallet,\n\t\tstring memory  ProjectId,\n\t\tstring memory  GranttId\n\t) public virtual {\n\t\tAllGrantVotes[GrantVoteId] = [GranttId,ProjectId,Wallet];\n\n\t}\n\n\nfunction createGrantVote(string memory Wallet,uint256 ProjectId,uint256 GranttId)\n\t\tpublic\n\t\treturns (uint256)\n\t{\n\t\tsetGrantVote(_GrantVoteIds, Wallet,Strings.toString(ProjectId),Strings.toString(GranttId));\n\t\t_GrantVoteIds++;\n\n\t\treturn _GrantVoteIds;\n\t}\nfunction getSearchedGrantVoteProject(uint256 Grantid,uint256 ProjectId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (string[] memory)\n\t{\n\t\t\n\t\tuint256 _TemporarySearch = 0;\n\t\tuint256 _SearchIds = 0;\n\t\t\n\t\t\n\t\tfor (uint256 i = 0; i < _GrantVoteIds; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(AllGrantVotes[i][0])) == keccak256(bytes(Strings.toString(Grantid))) &&\n\t\t\t\tkeccak256(bytes(AllGrantVotes[i][1])) == keccak256(bytes(Strings.toString(ProjectId)))\n\t\t\t\t\n\t\t\t) {\n\t\t\t\t_TemporarySearch++;\n\t\t\t}\n\t\t}\n\t\tstring[] memory _SearchedProject = new string[](_TemporarySearch);\n\n\t\n\t\tfor (uint256 i = 0; i < _GrantVoteIds; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(AllGrantVotes[i][0])) == keccak256(bytes(Strings.toString(Grantid))) &&\n\t\t\t\tkeccak256(bytes(AllGrantVotes[i][1])) == keccak256(bytes(Strings.toString(ProjectId)))\n\t\t\t\t\n\t\t\t) {\n\t\t\t_SearchedProject[_SearchIds] = AllGrantVotes[i][2];\n\t\t\t_SearchIds++;\n\t\t\t}\n\t\t}\n\n\n\t\treturn _SearchedProject;\n\t}\n\n\n\nfunction gettokenIdByUri(string memory _tokenURI)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\tfor (uint256 i = 0; i < _tokenIds; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(_tokenURIs[i])) == keccak256(bytes(_tokenURI))\n\t\t\t) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n\nfunction getEventIdByURI(string memory _eventURI)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\tfor (uint256 i = 0; i < _eventIds; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(_eventURIs[i][1])) == keccak256(bytes(_eventURI))\n\t\t\t) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\nfunction getBidIdByUri(string memory _bidURI)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\tfor (uint256 i = 0; i < _bidIds; i++) {\n\t\t\tif (keccak256(bytes(_bidURIs[i])) == keccak256(bytes(_bidURI))) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\nfunction gettokenSearchEventTotal(uint256 EventID)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (string[] memory)\n\t{\n\t\tstring[] memory _SearchedStoreToken = new string[](10);\n\n\t\tuint256 _EventTokenSearchIds2 = 0;\n\n\t\tfor (uint256 i = 0; i < _EventTokenIds; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(AllEventTokens[i][0])) ==\n\t\t\t\tkeccak256(bytes(Strings.toString(EventID)))\n\t\t\t) {\n\t\t\t\t_SearchedStoreToken[_EventTokenSearchIds2] = AllEventTokens[i][\n\t\t\t\t\t1\n\t\t\t\t];\n\t\t\t\t_EventTokenSearchIds2++;\n\t\t\t}\n\t\t}\n\n\t\treturn _SearchedStoreToken;\n\t}\n\nfunction getSearchEventbyWallet(string memory Wallet)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (string[] memory)\n\t{\n\t\n\t\tuint256 _TemporarySearch = 0;\n\t\tuint256 _SearchIds = 0;\n\n\t\tfor (uint256 i = 0; i < _eventIds; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(_eventURIs[i][0])) ==\n\t\t\t\tkeccak256(bytes(Wallet))\n\t\t\t) {\n\t\t\t\t_TemporarySearch++;\n\t\t\t}\n\t\t}\n\t\tstring[] memory _SearchedStoreEvents = new string[](_TemporarySearch);\n\t\tfor (uint256 i = 0; i < _eventIds; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(_eventURIs[i][0])) ==\n\t\t\t\tkeccak256(bytes(Wallet))\n\t\t\t) {\n\t\t\t\t_SearchedStoreEvents[_SearchIds] = _eventURIs[i][1];\n\t\t\t\t_SearchIds++;\n\t\t\t}\n\t\t}\n\n\n\t\treturn _SearchedStoreEvents;\n\t}\n\nfunction getGetEventsTokenID(uint256 EventId, string memory _tokenURI)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\tfor (uint256 i = 0; i < _EventTokenIds; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(AllEventTokens[i][0])) ==\n\t\t\t\tkeccak256(bytes(Strings.toString(EventId))) &&\n\t\t\t\tkeccak256(bytes(AllEventTokens[i][1])) ==\n\t\t\t\tkeccak256(bytes(_tokenURI))\n\t\t\t) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\nfunction _getSearchedTokenURI(uint256 _tokenId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (string memory)\n\t{\n\t\treturn _SearchedStore[_tokenId][0];\n\t}\n\nfunction _setEventURI(uint256 eventId,  string memory _eventWallet ,string memory _eventURI)\n\t\tpublic\n\t\tvirtual\n\t{\n\t\t_eventURIs[eventId] = [\n\t\t\t_eventWallet,\n\t\t\t_eventURI\n\t\t];\n\t\t_eventRaised[eventId] = \"0\";\n\t}\n\nfunction _setGrantEventURI(uint256 eventId, string memory _eventURI)\n\t\tpublic\n\t\tvirtual\n\t{\n\t\t_GrantEventURIs[eventId] = _eventURI;\n\t}\n\n\nfunction _setTokenURI(uint256 tokenId, string memory _tokenURI)\n\t\tpublic\n\t\tvirtual\n\t{\n\t\t_tokenURIs[tokenId] = _tokenURI;\n\t}\n\nfunction eventURI(uint256 eventId) public view returns (string[2] memory) {\n\t\treturn _eventURIs[eventId];\n\t}\n\nfunction tokenURI(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (string memory)\n\t{\n\n\t\treturn _tokenURIs[tokenId];\n\t}\n\nfunction totalSupply() public view returns (uint256) {\n\t\treturn _tokenIds;\n\t}\n\nfunction totalEvent() public view returns (uint256) {\n\t\treturn _eventIds;\n\t}\n\nfunction totalGrantEvent() public view returns (uint256) {\n\t\treturn _GrantProjectIds;\n\t}\n\nfunction _setBidURI(uint256 bidId, string memory _bidURI) public virtual {\n\t\t_bidURIs[bidId] = _bidURI;\n\t}\n\nfunction BidURI(uint256 BidId) public view returns (string memory) {\n\t\treturn _bidURIs[BidId];\n\t}\n\nfunction getTotalBid(uint256 TokenID)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (string[] memory)\n\t{\n\t\tstring[] memory _SearchedStoreBid = new string[](10);\n\n\t\tuint256 _TokenBidSearchIds2 = 0;\n\n\t\tfor (uint256 i = 0; i < _TokenBidIds; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(AllTokensBids[i][0])) ==\n\t\t\t\tkeccak256(bytes(Strings.toString(TokenID)))\n\t\t\t) {\n\t\t\t\t_SearchedStoreBid[_TokenBidSearchIds2] = AllTokensBids[i][1];\n\t\t\t\t_TokenBidSearchIds2++;\n\t\t\t}\n\t\t}\n\n\t\treturn _SearchedStoreBid;\n\t}\n\nfunction getBidsSearchToken(uint256 TokenID)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (string[] memory)\n\t{\n\t\tstring[] memory _SearchedStoreBid = new string[](10);\n\n\t\tuint256 _TokenBidSearchIds2 = 0;\n\n\t\tfor (uint256 i = 0; i < _TokenBidIds; i++) {\n\t\t\tif (\n\t\t\t\tkeccak256(bytes(AllTokensBids[i][0])) ==\n\t\t\t\tkeccak256(bytes(Strings.toString(TokenID)))\n\t\t\t) {\n\t\t\t\t_SearchedStoreBid[_TokenBidSearchIds2] = AllTokensBids[i][1];\n\t\t\t\t_TokenBidSearchIds2++;\n\t\t\t}\n\t\t}\n\n\t\treturn _SearchedStoreBid;\n\t}\n\nfunction _setTokenBid(\n\t\tuint256 TokenBidId,\n\t\tuint256 TokenId,\n\t\tstring memory _BidURI\n\t) public virtual {\n\t\tAllTokensBids[TokenBidId] = [\n\t\t\tStrings.toString(TokenId),\n\t\t\tstring(_BidURI)\n\t\t];\n\t}\n \nfunction getEventRaised(uint256 _eventId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (string memory)\n\t{\n\t\treturn _eventRaised[_eventId];\n\t}\n\nfunction _setEventRaised(uint256 _eventId, string memory _raised)\n\t\tpublic\n\t{\n\t\t_eventRaised[_eventId] = _raised;\n\t}\n\n function createBid(\n\t\tuint256 _tokenId,\n\t\tstring memory _bidURI,\n\t\tstring memory _updatedURI,\n\t\tuint256 _eventid,\n\t\tstring memory _raised\n\t) public   {\n\t\tuint256 _EventTokenId = getGetEventsTokenID(\n\t\t\t_eventid,\n\t\t\t_tokenURIs[_tokenId]\n\t\t);\n\t\t_tokenURIs[_tokenId] = _updatedURI;\n\t\t_setTokenEvent(_EventTokenId, _eventid, _updatedURI);\n\t\t_setEventRaised(_eventid,_raised);\n\n\t\t_setTokenBid(_TokenBidIds, _tokenId, _bidURI);\n\t\t_TokenBidIds++;\n\t\t_bidIds++;\n\t}\n\n\n\n    // Doante with a validator Address\n    function donate(uint256 _event_id,uint256 _amount) public payable  {\n        _approveRequiredMsgs();\n        donated[_event_id] += _amount;\n    }\n\n    function stake(uint256 _amount) public {\n        STAKING_CONTRACT.delegate(address(this), _validatorAddr, _amount);\n\n    }\n\n    function withdrawDonatedMoney(uint256 _event_id) public returns (int64) {      \n        _approveRequiredMsgs();\n        //Sotring Rewards to smart contract\n        Coin[] memory newRewards = DISTRIBUTION_CONTRACT.withdrawDelegatorRewards(address(this), _validatorAddr);\n     \n        //Withdrawing just unbounding\n        uint256 _amount = donated[_event_id];\n        int64 completionTime = STAKING_CONTRACT.undelegate(address(this), _validatorAddr, _amount);\n        //Saving undelegated amount into struct by event_id\n        unbondingDelegations[_event_id] = UnbondingRequest(completionTime, unbondingDelegations[_event_id].amount + _amount);\n\n        //Just withdrawing rewards now\n        uint256 _rewards_amount = newRewards[0].amount;\n        (bool sent,) = payable(msg.sender).call{value: _rewards_amount}(\"\");     \n        donated[_event_id] = 0;\n        return  completionTime;\n    }\n   /// @dev approves the staking and distribution contracts for donating\n    function _approveRequiredMsgs() public {\n        bool successStk = STAKING_CONTRACT.approve(tx.origin,   type(uint256).max, stakingMethods);\n        require(successStk, \"Staking Approve failed\");\n        bool successDist = DISTRIBUTION_CONTRACT.approve(tx.origin, distributionMethods);\n        require(successDist, \"Distribution Approve failed\");\n    }\n\n}\n\n\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/precompiles/stateful/Staking.sol": {
      "content": "// SPDX-License-Identifier: LGPL-v3\npragma solidity >=0.8.17;\n\nimport \"../common/Authorization.sol\" as authorization;\nimport \"../common/Types.sol\";\n\n/// @dev The StakingI contract's address.\naddress constant STAKING_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000800;\n\n/// @dev The StakingI contract's instance.\nStakingI constant STAKING_CONTRACT = StakingI(STAKING_PRECOMPILE_ADDRESS);\n\n/// @dev Define all the available staking methods.\nstring constant MSG_DELEGATE = \"/cosmos.staking.v1beta1.MsgDelegate\";\nstring constant MSG_UNDELEGATE = \"/cosmos.staking.v1beta1.MsgUndelegate\";\nstring constant MSG_REDELEGATE = \"/cosmos.staking.v1beta1.MsgBeginRedelegate\";\nstring constant MSG_CANCEL_UNDELEGATION = \"/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation\";\n\n/// @dev Defines the initial commission rates to be used for creating\n/// a validator.\nstruct CommissionRates {\n    uint256 rate;\n    uint256 maxRate;\n    uint256 maxChangeRate;\n}\n\n/// @dev Defines commission parameters for a given validator.\nstruct Commission {\n    CommissionRates commissionRates;\n    uint256 updateTime;\n}\n\n\n/// @dev Represents a validator in the staking module.\nstruct Validator {\n    string operatorAddress;\n    string consensusPubkey;\n    bool jailed;\n    BondStatus status;\n    uint256 tokens;\n    uint256 delegatorShares;\n    string description;\n    int64 unbondingHeight;\n    int64 unbondingTime;\n    uint256 commission;\n    uint256 minSelfDelegation;\n}\n\nstruct RedelegationResponse {\n    Redelegation redelegation;\n    RedelegationEntryResponse[] entries;\n}\n\nstruct Redelegation {\n    RedelegationEntry[] entries;\n}\n\nstruct RedelegationEntryResponse {\n    RedelegationEntry redelegationEntry;\n    uint256 balance;\n}\n\nstruct RedelegationEntry {\n    int64 creationHeight;\n    int64 completionTime;\n    uint256 initialBalance;\n    uint256 sharesDst;\n}\n\nstruct UnbondingDelegationEntry {\n    int64 creationHeight;\n    int64 completionTime;\n    uint256 initialBalance;\n    uint256 balance;\n}\n\nstruct PageRequest {\n    bytes key;\n    uint64 offset;\n    uint64 limit;\n    bool countTotal;\n    bool reverse;\n}\n\n/// @dev The status of the validator.\nenum BondStatus {\n    Unspecified,\n    Unbonded,\n    Unbonding,\n    Bonded\n}\n\n/// @author Evmos Team\n/// @title Staking Precompiled Contract\n/// @dev The interface through which solidity contracts will interact with staking.\n/// We follow this same interface including four-byte function selectors, in the precompile that\n/// wraps the pallet.\n/// @custom:address 0x0000000000000000000000000000000000000800\ninterface StakingI is authorization.AuthorizationI {\n    /// @dev Defines a method for performing a delegation of coins from a delegator to a validator.\n    /// @param delegatorAddress The address of the delegator\n    /// @param validatorAddress The address of the validator\n    /// @param amount The amount of the Coin to be delegated to the validator\n    function delegate(\n        address delegatorAddress,\n        string memory validatorAddress,\n        uint256 amount\n    ) external returns (int64 completionTime);\n\n    /// @dev Defines a method for performing an undelegation from a delegate and a validator.\n    /// @param delegatorAddress The address of the delegator\n    /// @param validatorAddress The address of the validator\n    /// @param amount The amount to be undelegated from the validator\n    /// @return completionTime The time when the undelegation is completed\n    function undelegate(\n        address delegatorAddress,\n        string memory validatorAddress,\n        uint256 amount\n    ) external returns (int64 completionTime);\n\n    /// @dev Defines a method for performing a redelegation\n    /// of coins from a delegator and source validator to a destination validator.\n    /// @param delegatorAddress The address of the delegator\n    /// @param validatorSrcAddress The validator from which the redelegation is initiated\n    /// @param validatorDstAddress The validator to which the redelegation is destined\n    /// @param amount The amount to be redelegated to the validator\n    /// @return completionTime The time when the redelegation is completed\n    function redelegate(\n        address delegatorAddress,\n        string memory validatorSrcAddress,\n        string memory validatorDstAddress,\n        uint256 amount\n    ) external returns (int64 completionTime);\n\n    /// @dev Allows delegators to cancel the unbondingDelegation entry\n    /// and to delegate back to a previous validator.\n    /// @param delegatorAddress The address of the delegator\n    /// @param validatorAddress The address of the validator\n    /// @param amount The amount of the Coin\n    /// @param creationHeight The height at which the unbonding took place\n    /// @return completionTime The time when the cancellation of the unbonding delegation is completed\n    function cancelUnbondingDelegation(\n        address delegatorAddress,\n        string memory validatorAddress,\n        uint256 amount,\n        uint256 creationHeight\n    ) external returns (int64 completionTime);\n\n    /// @dev Queries the given amount of the bond denomination to a validator.\n    /// @param delegatorAddress The address of the delegator.\n    /// @param validatorAddress The address of the validator.\n    /// @return shares The amount of shares, that the delegator has received.\n    /// @return balance The amount in Coin, that the delegator has delegated to the given validator.\n    function delegation(\n        address delegatorAddress,\n        string memory validatorAddress\n    ) external view returns (uint256 shares, Coin calldata balance);\n\n    /// @dev Returns the delegation shares and coins, that are currently\n    /// unbonding for a given delegator and validator pair.\n    /// @param delegatorAddress The address of the delegator.\n    /// @param validatorAddress The address of the validator.\n    /// @return entries The delegations that are currently unbonding.\n    function unbondingDelegation(\n        address delegatorAddress,\n        string memory validatorAddress\n    ) external view returns (UnbondingDelegationEntry[] calldata entries);\n\n    /// @dev Queries validator info for a given validator address.\n    /// @param validatorAddress The address of the validator.\n    /// @return validators The validator info for the given validator address.\n    function validator(\n        string memory validatorAddress\n    )\n    external view returns (\n        Validator[] calldata validators\n    );\n\n    /// @dev Queries all validators that match the given status.\n    /// @param status Enables to query for validators matching a given status.\n    /// @param pageRequest Defines an optional pagination for the request.\n    function validators(\n        string memory status,\n        PageRequest calldata pageRequest\n    ) external view returns (\n        Validator[] calldata validators,\n        PageResponse calldata pageResponse\n    );\n\n    /// @dev Queries all redelegations from a source to a destination validator for a given delegator.\n    /// @param delegatorAddress The address of the delegator.\n    /// @param srcValidatorAddress Defines the validator address to redelegate from.\n    /// @param dstValidatorAddress Defines the validator address to redelegate to.\n    /// @return entries The active redelegations for the given delegator, source and destination validator combination.\n    function redelegation(\n        address delegatorAddress,\n        string memory srcValidatorAddress,\n        string memory dstValidatorAddress\n    ) external view returns (RedelegationEntry[] calldata entries);\n\n    /// @dev Queries all redelegations from a source to to a destination validator\n    /// for a given delegator in a specified pagination manner.\n    /// @param delegatorAddress The address of the delegator.\n    /// @param srcValidatorAddress Defines the validator address to redelegate from.\n    /// @param dstValidatorAddress Defines the validator address to redelegate to.\n    /// @param pageRequest Defines an optional pagination for the request.\n    /// @return response Holds the redelegations for the given delegator, source and destination validator combination.\n    function redelegations(\n        address delegatorAddress,\n        string memory srcValidatorAddress,\n        string memory dstValidatorAddress,\n        PageRequest calldata pageRequest\n    ) external view returns (RedelegationResponse calldata response);\n\n    /// @dev Delegate defines an Event emitted when a given amount of tokens are delegated from the\n    /// delegator address to the validator address.\n    /// @param delegatorAddress The address of the delegator\n    /// @param validatorAddress The address of the validator\n    /// @param amount The amount of Coin being delegated\n    /// @param newShares The new delegation shares being held\n    event Delegate(\n        address indexed delegatorAddress,\n        string indexed validatorAddress,\n        uint256 amount,\n        uint256 newShares\n    );\n\n    /// @dev Unbond defines an Event emitted when a given amount of tokens are unbonded from the\n    /// validator address to the delegator address.\n    /// @param delegatorAddress The address of the delegator\n    /// @param validatorAddress The address of the validator\n    /// @param amount The amount of Coin being unbonded\n    /// @param completionTime The time at which the unbonding is completed\n    event Unbond(\n        address indexed delegatorAddress,\n        string indexed validatorAddress,\n        uint256 amount,\n        uint256 completionTime\n    );\n\n    /// @dev Redelegate defines an Event emitted when a given amount of tokens are redelegated from\n    /// the source validator address to the destination validator address.\n    /// @param delegatorAddress The address of the delegator\n    /// @param validatorSrcAddress The address of the validator from which the delegation is retracted\n    /// @param validatorDstAddress The address of the validator to which the delegation is directed\n    /// @param amount The amount of Coin being redelegated\n    /// @param completionTime The time at which the redelegation is completed\n    event Redelegate(\n        address indexed delegatorAddress,\n        string indexed validatorSrcAddress,\n        string indexed validatorDstAddress,\n        uint256 amount,\n        uint256 completionTime\n    );\n\n    /// @dev CancelUnbondingDelegation defines an Event emitted when a given amount of tokens\n    /// that are in the process of unbonding from the validator address are bonded again.\n    /// @param delegatorAddress The address of the delegator\n    /// @param validatorAddress The address of the validator\n    /// @param amount The amount of Coin that was in the unbonding process which is to be cancelled\n    /// @param creationHeight The block height at which the unbonding of a delegation was initiated\n    event CancelUnbondingDelegation(\n        address indexed delegatorAddress,\n        string indexed validatorAddress,\n        uint256 amount,\n        uint256 creationHeight\n    );\n}\n"
    },
    "contracts/precompiles/stateful/Distribution.sol": {
      "content": "// SPDX-License-Identifier: LGPL-v3\npragma solidity >=0.8.17;\n\nimport \"../common/GenericAuthorization.sol\" as genericAuth;\nimport \"../common/Types.sol\";\n\n/// @dev The DistributionI contract's address.\naddress constant DISTRIBUTION_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000801;\n\n/// @dev Define all the available distribution methods.\nstring constant MSG_SET_WITHDRAWER_ADDRESS = \"/cosmos.distribution.v1beta1.MsgSetWithdrawAddress\";\nstring constant MSG_WITHDRAW_DELEGATOR_REWARD = \"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\";\nstring constant MSG_WITHDRAW_VALIDATOR_COMMISSION = \"/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission\";\n\n/// @dev The DistributionI contract's instance.\nDistributionI constant DISTRIBUTION_CONTRACT = DistributionI(DISTRIBUTION_PRECOMPILE_ADDRESS);\n\nstruct ValidatorSlashEvent {\n    uint64 validatorPeriod;\n    Dec fraction;\n}\n\nstruct ValidatorDistributionInfo {\n    string operatorAddress;\n    DecCoin[] selfBondRewards;\n    DecCoin[] commission;\n}\n\nstruct DelegationDelegatorReward {\n    string validatorAddress;\n    DecCoin[] reward;\n}\n\n/// @author Evmos Team\n/// @title Distribution Precompile Contract\n/// @dev The interface through which solidity contracts will interact with Distribution\n/// @custom:address 0x0000000000000000000000000000000000000801\ninterface DistributionI is genericAuth.GenericAuthorizationI {\n    /// TRANSACTIONS\n    /// @dev Change the address, that can withdraw the rewards of a delegator.\n    /// Note that this address cannot be a module account.\n    /// @param delegatorAddress The address of the delegator\n    /// @param withdrawerAddress The address that will be capable of withdrawing rewards for\n    /// the given delegator address\n    function setWithdrawAddress(\n        address delegatorAddress,\n        string memory withdrawerAddress\n    ) external returns (bool success);\n\n    /// @dev Withdraw the rewards of a delegator from a validator\n    /// @param delegatorAddress The address of the delegator\n    /// @param validatorAddress The address of the validator\n    /// @return amount The amount of Coin withdrawn\n    function withdrawDelegatorRewards(\n        address delegatorAddress,\n        string memory validatorAddress\n    )\n    external\n    returns (\n        Coin[] calldata amount\n    );\n\n    /// @dev Withdraws the rewards commission of a validator.\n    /// @param validatorAddress The address of the validator\n    /// @return amount The amount of Coin withdrawn\n    function withdrawValidatorCommission(\n        string memory validatorAddress\n    )\n    external\n    returns (\n        Coin[] calldata amount\n    );\n\n    /// QUERIES\n    /// @dev Queries validator commission and self-delegation rewards for validator.\n    /// @param validatorAddress The address of the validator\n    /// @return distributionInfo The validator's distribution info\n    function validatorDistributionInfo(\n        string memory validatorAddress\n    )\n    external\n    view\n    returns (\n        ValidatorDistributionInfo[] calldata distributionInfo // FIXME: remove unnecessary slice\n    );\n\n    /// @dev Queries the outstanding rewards of a validator address.\n    /// @param validatorAddress The address of the validator\n    /// @return rewards The validator's outstanding rewards\n    function validatorOutstandingRewards(\n        string memory validatorAddress\n    )\n    external\n    view\n    returns (\n        DecCoin[] calldata rewards\n    );\n\n    /// @dev Queries the accumulated commission for a validator.\n    /// @param validatorAddress The address of the validator\n    /// @return commission The validator's commission\n    function validatorCommission(\n        string memory validatorAddress\n    )\n    external\n    view\n    returns (\n        DecCoin[] calldata commission\n    );\n\n    /// @dev Queries the slashing events for a validator in a given height interval\n    /// defined by the starting and ending height.\n    /// @param validatorAddress The address of the validator\n    /// @param startingHeight The starting height\n    /// @param endingHeight The ending height\n    /// @return slashes The validator's slash events\n    /// @return pageResponse The pagination response for the query\n    function validatorSlashes(\n        string memory validatorAddress,\n        uint64 startingHeight,\n        uint64 endingHeight\n    )\n    external\n    view\n    returns (\n        ValidatorSlashEvent[] calldata slashes,\n        PageResponse calldata pageResponse\n    );\n\n    /// @dev Queries the total rewards accrued by a delegation from a specific address to a given validator.\n    /// @param delegatorAddress The address of the delegator\n    /// @param validatorAddress The address of the validator\n    /// @return rewards The total rewards accrued by a delegation.\n    function delegationRewards(\n        address delegatorAddress,\n        string memory validatorAddress\n    )\n    external\n    view\n    returns (\n        DecCoin[] calldata rewards\n    );\n\n    /// @dev Queries the total rewards accrued by each validator, that a given\n    /// address has delegated to.\n    /// @param delegatorAddress The address of the delegator\n    /// @return rewards The total rewards accrued by each validator for a delegator.\n    /// @return total The total rewards accrued by a delegator.\n    function delegationTotalRewards(\n        address delegatorAddress\n    )\n    external\n    view\n    returns (\n        DelegationDelegatorReward[] calldata rewards,\n        DecCoin[] calldata total\n    );\n\n    /// @dev Queries all validators, that a given address has delegated to.\n    /// @param delegatorAddress The address of the delegator\n    /// @return validators The addresses of all validators, that were delegated to by the given address.\n    function delegatorValidators(\n        address delegatorAddress\n    ) external view returns (string[] calldata validators);\n\n    /// @dev Queries the address capable of withdrawing rewards for a given delegator.\n    /// @param delegatorAddress The address of the delegator\n    /// @return withdrawAddress The address capable of withdrawing rewards for the delegator.\n    function delegatorWithdrawAddress(\n        address delegatorAddress\n    ) external view returns (string memory withdrawAddress);\n\n    /// @dev SetWithdrawerAddress defines an Event emitted when a new withdrawer address is being set\n    /// @param caller the caller of the transaction\n    /// @param withdrawerAddress the newly set withdrawer address\n    event SetWithdrawerAddress(\n        address indexed caller,\n        string withdrawerAddress\n    );\n\n    /// @dev WithdrawDelegatorRewards defines an Event emitted when rewards from a delegation are withdrawn\n    /// @param delegatorAddress the address of the delegator\n    /// @param validatorAddress the address of the validator\n    /// @param amount the amount being withdrawn from the delegation\n    event WithdrawDelegatorRewards(\n        address indexed delegatorAddress,\n        string indexed validatorAddress,\n        uint256 amount\n    );\n\n    /// @dev WithdrawValidatorCommission defines an Event emitted when validator commissions are being withdrawn\n    /// @param validatorAddress is the address of the validator\n    /// @param commission is the total commission earned by the validator\n    event WithdrawValidatorCommission(\n        string indexed validatorAddress,\n        uint256 commission\n    );\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "contracts/precompiles/common/Authorization.sol": {
      "content": "// SPDX-License-Identifier: LGPL-v3\npragma solidity >=0.8.17;\n\n/// @author Evmos Team\n/// @title Authorization Interface\n/// @dev The interface through which solidity contracts will interact with smart contract approvals.\ninterface AuthorizationI {\n    /// @dev Approves a list of Cosmos or IBC transactions with a specific amount of tokens.\n    /// @param spender The address which will spend the funds.\n    /// @param amount The amount of tokens to be spent.\n    /// @param methods The message type URLs of the methods to approve.\n    /// @return approved Boolean value to indicate if the approval was successful.\n    function approve(\n        address spender,\n        uint256 amount,\n        string[] calldata methods\n    ) external returns (bool approved);\n\n    /// @dev Increase the allowance of a given spender by a specific amount of tokens for IBC\n    /// transfer methods or staking.\n    /// @param spender The address which will spend the funds.\n    /// @param amount The amount of tokens to be spent.\n    /// @param methods The message type URLs of the methods to approve.\n    /// @return approved Boolean value to indicate if the approval was successful.\n    function increaseAllowance(\n        address spender,\n        uint256 amount,\n        string[] calldata methods\n    ) external returns (bool approved);\n\n    /// @dev Decreases the allowance of a given spender by a specific amount of tokens for IBC\n    /// transfer methods or staking.\n    /// @param spender The address which will spend the funds.\n    /// @param amount The amount of tokens to be spent.\n    /// @param methods The message type URLs of the methods to approve.\n    /// @return approved Boolean value to indicate if the approval was successful.\n    function decreaseAllowance(\n        address spender,\n        uint256 amount,\n        string[] calldata methods\n    ) external returns (bool approved);\n\n\n    /// @dev Returns the remaining number of tokens that spender will be allowed to spend\n    /// on behalf of the owner through IBC transfer methods or staking. This is zero by default.\n    /// @param owner The address of the account owning tokens.\n    /// @param spender The address of the account able to transfer the tokens.\n    /// @param method The message type URL of the methods for which the approval should be queried.\n    /// @return remaining The remaining number of tokens available to be spent.\n    function allowance(\n        address owner,\n        address spender,\n        string calldata method\n    ) external view returns (uint256 remaining);\n\n    /// @dev This event is emitted when the allowance of a spender is set by a call to the approve method.\n    /// The value field specifies the new allowance and the methods field holds the information for which methods\n    /// the approval was set.\n    /// @param owner The owner of the tokens.\n    /// @param spender The address which will spend the funds.\n    /// @param methods The message type URLs of the methods for which the approval is set.\n    /// @param value The amount of tokens approved to be spent.\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        string[] methods,\n        uint256 value\n    );\n\n    /// @dev This event is emitted when the allowance of a spender is changed by a call to the decrease or increase\n    /// allowance method. The values field specifies the new allowances and the methods field holds the\n    /// information for which methods the approval was set.\n    /// @param owner The owner of the tokens.\n    /// @param spender The address which will spend the funds.\n    /// @param methods The message type URLs of the methods for which the approval is set.\n    /// @param values The amounts of tokens approved to be spent.\n    event AllowanceChange(\n        address indexed owner,\n        address indexed spender,\n        string[] methods,\n        uint256[] values\n    );\n}\n"
    },
    "contracts/precompiles/common/Types.sol": {
      "content": "// SPDX-License-Identifier: LGPL-v3\npragma solidity >=0.8.17;\n\nstruct Dec {\n    uint256 value;\n    uint8 precision;\n}\n\n/// @dev Coin is a struct that represents a token with a denomination and an amount.\nstruct Coin {\n    string denom;\n    uint256 amount;\n}\n\n/// @dev DecCoin is a struct that represents a token with a denomination, an amount and a precision.\nstruct DecCoin {\n    string denom;\n    uint256 amount;\n    uint8 precision;\n}\n\n/// @dev PageResponse is a struct that represents a page response.\nstruct PageResponse {\n    bytes nextKey;\n    uint64 total;\n}\n"
    },
    "contracts/precompiles/common/GenericAuthorization.sol": {
      "content": "// SPDX-License-Identifier: LGPL-v3\npragma solidity >=0.8.17;\n\n/// @author Evmos Team\n/// @title Authorization Interface\n/// @dev The interface through which solidity contracts will interact with smart contract approvals.\ninterface GenericAuthorizationI {\n    /// @dev Approves a list of Cosmos or IBC transactions with a specific amount of tokens.\n    /// @param spender The address which will spend the funds.\n    /// @param methods The message type URLs of the methods to approve.\n    /// @return approved Boolean value to indicate if the approval was successful.\n    function approve(\n        address spender,\n        string[] calldata methods\n    ) external returns (bool approved);\n\n    /// @dev Revokes a list of Cosmos transactions.\n    /// @param spender The address which will spend the funds.\n    /// @param methods The message type URLs of the methods to revoke.\n    /// @return revoked Boolean value to indicate if the revocation was successful.\n    function revoke(\n        address spender,\n        string[] calldata methods\n    ) external returns (bool revoked);\n\n    /// @dev This event is emitted when the allowance of a spender is set by a call to the approve method.\n    /// The value field specifies the new allowance and the methods field holds the information for which methods\n    /// the approval was set.\n    /// @param owner The owner of the tokens.\n    /// @param spender The address which will spend the funds.\n    /// @param methods The message type URLs of the methods for which the approval is set.\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        string[] methods\n    );\n\n    /// @dev This event is emitted when an owner revokes a spender's allowance.\n    /// @param owner The owner of the tokens.\n    /// @param spender The address which will spend the funds.\n    /// @param methods The message type URLs of the methods for which the approval is set.\n    event Revocation(\n        address indexed owner,\n        address indexed spender,\n        string[] methods\n    );\n}\n"
    },
    "contracts/precompiles/stateful/IBCTransfer.sol": {
      "content": "// SPDX-License-Identifier: LGPL-v3\npragma solidity >=0.8.17;\n\n/// @dev The ICS20I contract's address.\naddress constant IBC_TRANSFER_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000802;\n\n/// @dev The ICS20 contract's instance.\nIBCTransferI constant IBC_TRANSFER_CONTRACT = IBCTransferI(IBC_TRANSFER_PRECOMPILE_ADDRESS);\n\n// Height is a monotonically increasing data type\n// that can be compared against another Height for the purposes of updating and\n// freezing clients\n//\n// Normally the RevisionHeight is incremented at each height while keeping\n// RevisionNumber the same. However some consensus algorithms may choose to\n// reset the height in certain conditions e.g. hard forks, state-machine\n// breaking changes In these cases, the RevisionNumber is incremented so that\n// height continues to be monotonically increasing even as the RevisionHeight\n// gets reset\nstruct Height {\n  // the revision that the client is currently on\n  uint64 revisionNumber;\n  // the height within the given revision\n  uint64 revisionHeight;\n}\n\n// DenomTrace contains the base denomination for ICS20 fungible tokens and the\n// source tracing information path.\nstruct DenomTrace {\n  // path defines the chain of port/channel identifiers used for tracing the\n\t// source of the fungible token.\n  string path;\n  // base denomination of the relayed fungible token.\n  string baseDenom;\n}\n\n/// @author Evmos Team\n/// @title ICS20 Transfer Precompiled Contract\n/// @dev The interface through which solidity contracts will interact with IBC Transfer (ICS20)\n/// FIXME: update address\n/// @custom:address 0x0000000000000000000000000000000000000802\ninterface IBCTransferI {\n    /// @dev Transfer defines a method for performing an IBC transfer.\n    /// @param sourcePort the address of the validator\n    /// @param sourceChannel the address of the validator\n    /// @param denom the denomination of the Coin to be transferred to the receiver\n    /// @param amount the amount of the Coin to be transferred to the receiver\n    /// @param sender the hex address of the sender\n    /// @param receiver the bech32 address of the receiver\n    /// @param timeoutHeight the bech32 address of the receiver\n    /// @param timeoutTimestamp the bech32 address of the receiver\n    /// @param memo the bech32 address of the receiver\n    function transfer(\n      string memory sourcePort,\n      string memory sourceChannel,\n      string memory denom,\n      uint256 amount,\n      address sender,\n      string memory receiver,\n      Height memory timeoutHeight,\n      uint64 timeoutTimestamp,\n      string memory memo\n    ) external returns (uint64 nextSequence);\n\n    /// @dev DenomTraces defines a method for returning all denom traces.\n    function denomTraces(\n    ) external returns (DenomTrace[] memory denomTraces);\n\n    /// @dev DenomTrace defines a method for returning a denom trace.\n    function denomTrace(\n      string memory hash\n    ) external returns (DenomTrace memory denomTrace);\n\n    /// @dev DenomHash defines a method for returning a hash of the denomination trace info.\n    function denomHash(\n      string memory trace\n    ) external returns (string memory hash);\n\n    /// @dev Approves IBC transfer with a specific amount of tokens.\n    /// @param spender spender The address which will spend the funds.\n    /// @param amount The amount of tokens to be spent.\n    function approve(\n        address spender,\n        uint256 amount\n    ) external returns (bool approved);\n\n    /// @dev Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through\n    /// IBC transfers. This is zero by default.\n    /// @param owner The address of the account owning tokens.\n    /// @param spender The address of the account able to transfer the tokens.\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256 remaining);\n\n    /// @dev Increase the allowance of a given spender by a specific amount of tokens for IBC transfer methods.\n    /// @param spender The address which will spend the funds.\n    /// @param amount The amount of tokens to be spent.\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool approved);\n\n    /// @dev Decreases the allowance of a given spender by a specific amount of tokens for for IBC transfer methods.\n    /// @param spender The address which will spend the funds.\n    /// @param amount The amount of tokens to be spent.\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool approved);\n\n\n    /// @dev Emitted when a transfer is executed.\n    /// @param sender The address of the sender.\n    /// @param receiver The address of the receiver.\n    /// @param denom The denomination of the tokens transferred.\n    /// @param amount The amount of tokens transferred.\n    event IBCTransfer(\n        address indexed sender,\n        address indexed receiver,\n        string denom,\n        uint256 amount\n    );\n\n    /// @dev Emitted when an approval is executed.\n    /// @param owner The address of the owner.\n    /// @param spender The address of the spender.\n    /// @param value The amount of tokens approved.\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/precompiles/stateless/Bech32.sol": {
      "content": "// SPDX-License-Identifier: LGPL-v3\npragma solidity >=0.8.17;\n\n/// @dev The Bech32I contract's address.\naddress constant Bech32_PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000400;\n\n/// @author Evmos Team\n/// @title Bech32 Precompiled Contract\n/// @dev The interface through which solidity contracts can convert addresses from\n/// hex to bech32 and vice versa.\n/// @custom:address 0x0000000000000000000000000000000000000010\ninterface Bech32I {\n    /// @dev Defines a method for converting a hex formatted address to bech32.\n    /// @param addr The hex address to be converted.\n    /// @param prefix The human readable prefix (HRP) of the bech32 address.\n    /// @return bech32Address The address in bech32 format.\n    function hexToBech32(\n        address addr,\n        string memory prefix\n    ) external returns (string memory bech32Address);\n\n    /// @dev Defines a method for converting a bech32 formatted address to hex.\n    /// @param bech32Address The bech32 address to be converted.\n    /// @return addr The address in hex format.\n    function bech32ToHex(\n        string memory bech32Address\n    ) external returns (address addr);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}